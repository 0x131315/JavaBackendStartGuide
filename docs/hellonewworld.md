#### Так держать

Если ты добрался до этого пункта, мы мысленно пожимаем тебе руку. Осилить такое количество материала и не сдаться — достойно уважения. Но наше путешествие продолжается. Имей в виду, что если Core ты должен знать назубок, то знание всего ниже перечисленного может варьироваться от базового до нормального. Полностью прокачаться можно, увы, только на реальной работе. 

#### Web-подготовка

Как ни странно, для того чтобы стать хорошим web-разработчиком, необходимо хорошо разбираться в этой самой паутине. И хотя базу обычно дают в университете, убедись, что ты помнишь/знаешь, что такое JSON, чем RESTful API отличается от SOAP, какие бывают HTTP-методы и прочие базовые штуки. Дальше по тексту подразумеваем, что ты не впадешь в ступор от слова "endpoint".

#### Системы сборки

Современные приложения редко состоят из парочки классов которые запускаются из среды разработки. Работа с зависимостями твоего проекта, его сборка/упаковка, всё это ответственность систем сборки. Они берут на себя нудную и иногда тяжелую работу, чтобы твой проект на развалился под грузом [JAR hell](https://dzone.com/articles/what-is-jar-hell). На 2022 год, в Java есть две наиболее популярных системы сборки:

1. [Gradle](https://gradle.org/). Модно, молодежно, инкрементальная компиляция, описание билд-файла на Groovy или Kotlin DSL. Быстрый старт [здесь](https://docs.gradle.org/current/samples/sample_building_java_applications.html).
2. [Maven](https://maven.apache.org/). Почти нестареющая классика. Описание билда файла на XML, есть множество плагинов на любой вкус, расширяющих стандартную функциональность. Быстрый старт [здесь](https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html).

Попробуй оба варианта, останься на том который тебе больше нравится. Явного фаворита среди них нет, Gradle часто ругают за сложность настройки, Maven за медлительность и многословность. На рынке они распределены почти 50/50, так что смотри сам. Мы советуем Maven, так как новичку зачастую проще работать именно с ним. С этого момента **все** твои проекты должны собираться только с использованием выбранной тобой системой сборки. Они используются в любом реальном проекте, и ты должен уметь такие проекты открывать, дорабатывать и собирать.

#### Тестирование

Ты можешь быть уверенным в качестве своего кода, но ещё больше уверенности тебе даст покрытие своего кода тестами. Тестирование это отдельная крупная тема для разговора. Их бывает много разных видов, разной степени полезности с использованием разных инструментов. Мы советуем начать с модульного (unit) тестирования. Наиболее популярным фреймворком для unit тестирования является JUnit. Начать своё погружение в этот увлекательный мир ты можешь

- со сборника статей Baeldung [здесь](https://www.baeldung.com/junit);
- с официальных [гайдов](https://junit.org/junit5/docs/current/user-guide/) JUnit.

#### Логирование

Чем крупнее твоё приложение, тем больше возникает необходимость понимать, что за процессы в нем происходят. Отладка возникающих ошибок, сбор статистики и многое другое практически невозможно без наличия логов. С системами логирования в Java всё очень плохо. Их много, у них разный подход к конфигурации, а ещё они могут связываться друг с другом в забавных франкенштейнов. Из наиболее популярного, обрати внимание на:

- Logback;
- Log4j2;
- JBoss logging.

Проще всего будет настроить SLF4J Simple по этому [мануалу](http://www.slf4j.org/manual.html). Сам SLF4J это фасад для движков логирования, вроде тех, что мы перечислили выше, но в нем есть возможность подключить небольшой встроенный движок, который отлично закроет твои начальные потребности. И помни, с этого момента в твоём коде не должно быть ни одного ```System.out.println```, только взрослое логирование.

#### SQL

Современный web-мир невозможен без данных, а где данные, там и базы данных. Тебе нужно понимать синтаксис SQL и уметь писать на нем запросы. В этом тебе поможет:

1. [Туториал](https://www.w3schools.com/sql/) от W3Schools;
2. Книга Алана Бьюли «Изучаем SQL»;
3. Прорешивание задачек на [SQL-EX](https://www.sql-ex.ru/learn_exercises.php);
4. Если у тебя есть доступ к HyperSkill, пройди раздел «Databases and SQL» вот [тут;](https://hyperskill.org/knowledge-map/520)
5. Интерактивный [тренажер](https://stepik.org/course/63054/promo) по SQL на Stepik, ориентированный на практические задачи с минимальной подачей теории.

Становится джедаем запросов не надо, но у тебя должно сложиться понимание как ты можешь вертеть данные на своей будущей БД.

#### Базы данных

После того как ты овладел SQL, самое время подключить к своему приложению настоящую базу данных. Систем управления базой данных великое множество, на начальном этапе обрати внимание на:

1. PostgreSQL/MySQL — классические реляционные СУБД;
2. H2 — легковесная in-memory СУБД, хорошо подойдет для твоих небольших проектов;
3. MongoDB — популярная NoSQL СУБД

Читать многотомные руководства на начальном пути обучения по ним не потребуется. Для начала тебе будет достаточно знать как установить СУБД и как заглянуть внутрь табличек.

##### JDBC

Итак, у тебя появилась база данных, теперь ты хочешь трогать её данные прямо из своего уютного кода. Тут на помощь придёт добрый дедушка JDBC. JDBC — это такое относительно низкоуровневое API (довольно старое, но супернадежное), которое предоставляет тебе возможность работать с твоей базой данной прямо из кода. Открываешь соединения, пишешь ручками запросы, отправляешь запрос на исполнение, получаешь выборку с результатами. Получается много кода, куча лапши `try-catch`, зато весьма производительно и гибко. В современном мире люди обычно пользуются инструментами более высокого уровня типа Spring Data, но не стоит забывать наши корни. Поэтому ознакомься на досуге с бесплатным руководством Oracle: [JDBC Basics](https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html)

#### ORM

Если ты ещё не задумывался о философских вопросах, то сейчас самое время. Вот живут у тебя таблицы в базе данных, связанные между собой в забавные клубки, и в ус не дуют. И с другой стороны баррикад, ты разработчик с горящими глазами и ворохом Java классов в твоем проекте. И хочешь ты, чтобы написал ты SQL-запрос и получил в ответ набор `List<MyObject>`, а не JDBC-выборку, обрабатывая которую руками, приходится создавать объекты и кастовать типы направо и налево как заправский колдун.

Такие страдания испытал не ты первый, поэтому умные люди собрались и придумали концепцию ORM. Основной смысл ORM в том, чтобы взять на себя тяжелую работу по преобразованию твоих Java-типов в типы базы данных и обратно. Ты как разработчик аннотируешь свои классы оставляя подсказки для фреймворка какие типы ты хочешь получить, а потом просто пользуешься обычными методами. Написал `save(ListWithMyObjects)`, а он сам как по волшебству, превратился в SQL-запрос и обновил данные. 

Звучит слишком хорошо, чтобы быть правдой, не так ли? Так и есть. Правильная готовка ORM — это настоящая головная боль и балансирование на острие ножа, но тебе придется к этому прикоснуться.

##### Hibernate

Он же просто хибер. Самый популярный Java-фреймворк, предназначенный для решения ORM задач. Море возможностей, море подводных камней, море страданий. Профессионально его готовить мало кто умеет, но приобщиться надо. Материалов по нему великое множество, но обрати внимание на эти:

- Один из самых известных Hibernate-профессионалов, Vlad Mihalcea, ведет уютный [сайтик](https://vladmihalcea.com/tutorials/hibernate/) на котором содержатся десятки полезных статей, ответов на вопросы и обзоры подводных камней. Подпишись, читай, приобщайся. Когда у тебя на проекте выстрелит проблема по хиберу, Влад может прийти на помощь;
- Бауэр, Кинг, Грегори. Java Persistence API и Hibernate. Одновременно является и справочником и руководством. Написана тяжело, читается тяжело, но достаточно объемно покрывает необходимые темы. Читать, возможно, придется в несколько заходов, но лучше осилить;
- Официальная [документация](https://docs.jboss.org/hibernate/orm/5.5/userguide/html_single/Hibernate_User_Guide.html#preface). Написано хорошо, в меру разжевано, сопровождается примерами. Целиком читать необязательно,  но периодически заглядывать полезно.

### Основы CI/CD

Раньше, когда мир был медленнее, программы выпускались крупными релизами (иногда даже раз в год), которые чаще всего вручную устанавливались на сервер. Исправляющие патчи выпускали быстрее, но тоже не то чтобы очень часто.

В современном мире ситуация значительно изменилась. Наши пользователи не готовы ждать, пока вы наконец-то запилите такую необходимую для них фичу. Они хотят её здесь и сейчас. Разработчики подстроились под эти желания и изменили подход к своей работе. Если мы что-то делаем регулярно, зачем это делать вручную? Если всё есть код, то мы можем делать с ним что угодно, отправлять куда угодно. Так появилась методика непрерывной интеграции и непрерывного развертывания. 

Разработчик запушил новую фичу? Пора сделать рутинные действия: получить свежие изменения, запустить юнит-тесты, собрать приложение под нужные платформы, развернуть тестовое окружение и запустить интеграционные тесты. Все этапы прошли успешно? Значит, будем считать, что код стабилен и его можно отправить прямо на продуктив, где пользователи сразу получат такую долгожданную фичу и заметно веселее понесут бизнесу свои деньги. Все эти рутинные действия берет на себя система непрерывной интеграции. От нас требуется только предоставить ей необходимое окружение и предоставить скрипт конвейерной сборки. Всё остальное она берет на себя, активно работая на невидимом фронте, лишь периодически оповещая людей, если что-то пошло не так.

Звучит как идеальный мир, где все счастливы, но, к сожалению, в жизни всё несколько сложнее. Всегда есть перечень «Но» переменной длины, который вносит коррективы. Но сама концепция CI/CD и методология DevOps, к которой она относится, является сейчас крайне популярной и эффективной организацией создания и обновления наших продуктов. Ты найдешь ей применение практически на любом проекте.

#### Jenkins

Дженкинс — один из наиболее популярных серверов непрерывной интеграции. Что его делает таким популярным? Во-первых, он бесплатный и опенсорсный. Во-вторых, он **чрезвычайно** расширяемый благодаря сотням различных плагинов и библиотек. Не нашел нужную? Всегда можно запилить свою, ведь Jenkins написан на нашей любимой Java. Настройку наших конвейеров можно производить прямо на Groovy, что предоставляет нам практически неограниченные возможности. 

Из минусов можно отметить откровенно устаревший интерфейс, и понимание, что если что-то пошло не так, в поддержку не напишешь, придется ковыряться самому. Следствие бесплатности, увы.

Однако сделать свои первые шаги и запустить первые конвейеры довольно легко. Просто следуй официальному [гайду](https://www.jenkins.io/doc/pipeline/tour/getting-started/) и очень скоро твоё приложение научится тестировать и собирать само себя. Ну не чудо ли?

### Контейнеры

В смутные времена, когда возникала торжественная необходимость задеплоить приложение на прод, подготовить рабочее окружение для разработчика или просто прогнать тесты на тестовом стенде, приходилось всё это делать ручками. Ты наверняка сталкивался с этим в повседневной жизни: хочешь установить программу, а ей нужен, например, установленный .NET. А ему тоже что-то нужно. И так мы проходим иногда весьма длинную цепочку пока, наконец, не получаем установленную и возможно даже работающую программу. 

А что, если нам нужно переустановить систему? А что, если нужно это сделать на другой ОС? Со всем этим нам поможет технология упаковки приложений в контейнеры. Контейнеры позволяют нам инкапуслировать всю среду, которая необходима для работы нашей программы, внутри черного ящика. Это значит, что сама основная машина не будет замусориваться бесконечными библиотеками и доп. софтом, всё это будет аккуратно упаковано и не будет никому мешать. Удалил контейнер и вместе с ним уедет в небытие вся его обвязка. Никаких больше проблем с конфликтом версий у разного ПО. Счастье для всех, даром и никто не уйдет обиженным.

Исторически, у джавистов ещё в бородатые времена были сервлеты и контейнеры сервлетов, которые примерно про это, но не совсем. Однако, у всех остальных такого счастья не было и они придумали свои решения этой проблемы. Из тех, что наиболее на слуху, стоит отметить Docker и Kubernetes.

#### Docker

Docker, если по умному, — система по автоматизации и управлению нашими контейнерами. Мы ей даем контейнер, а она его запускает, настраивает и подготавливает к работе. Суть самих контейнеров простая как топор: мы описываем, в специальном формате, что нужно для нашего приложения (ОС, библиотеки и прочее). Весь **минимальный** набор, необходимый для корректной работы нашего приложения. А потом запекаем это как слоеный пирог. Собрал ты контейнер, у которого в основе Ubuntu и радуешься жизни, всё работает. А потом захотел стать модным и заменить убунту на alpine, поменял пару строк в своем файле и снова радуешься жизни. Docker хорош там, где нужно тестовое окружение или окружение для разработчика. 

Помни, что готовить докер в продуктиве гораздо сложнее, так как сразу возникает куча вопросов, например, по поводу производительности и безопасности. Для твоих учебных проектов это некритично, но в случае чего-то серьезного, лучше положиться на SRE-инженера / системного администратора. 

По учебным материалам обрати внимание на:

-  Jeff Nickolof. Docker in Action. Серия «in Action» обычно довольно качественная сжатая (но не чересчур), по самым разным темам. Докер не исключение, если хочешь быстро получить базовые знания, данная книга тебе поможет;
-  Официальная документация. Куда уж без документации. Написана хорошо, много полезных примеров и гайдов, не стесняйся туда почаще заглядывать.

После того как ознакомишься с учебными материалами, попробуй упаковать с помощью докера любое своё приложение и задеплоить, например, на Heroku. Гайд по деплою докер-образов в Heroku, можно найти [здесь](https://devcenter.heroku.com/categories/deploying-with-docker).

#### Kubernetes

Один контейнер — это хорошо, это надежно. Но что, если мы поддались волне хайпа и теперь у нас из всех щелей лезут микросервисы? Что, если контейнеров у нас десятки, если не сотни? Как управлять всем этим зоопарком и не сойти с ума? Здесь к нам на помощь придет оркестратор Kubernetes или просто кубер. По самому термину «оркестратор» можно догадаться, что его задача состоит в управлении и контроле за нашим многочисленным зоопарком контейнеров. Он позволяет нам их запускать, заменять на другие, следить за их состоянием, автоматически перезапускать, если кто-то упал и даже автоматически масштабироваться в зависимости от текущей нагрузки. 

К сожалению, с большой силой приходит большая головная боль, поэтому обычно с кубером работает специальный человек — SRE-инженер. SRE это такой умный человек, который следует философии DevOps. Если есть желание, можешь ознакомиться с бесплатной [книгой](https://sre.google/sre-book/table-of-contents/) от Google, где описывается их виденье данной профессии.

На начальном этапе тебе достаточно будет знать, что кубер существует, что он классный и его очень трудно готовить без соответствующего опыта.

### Конференции

Java-конференции — это такие партийные съезды всех пролетариев джавистов. Много докладов о том, как наши микросервисы бороздят просторы облаков, разбор кишочков популярных фреймворков и многое другое. 

Самое ценное в конференциях — это обмен опытом со своими братьями по цеху. Идеальное место, чтобы устраивать срачи с популярными Java-персоналиями, узнавать, чем сейчас дышат, и держать нос по ветру. В 2021 году всё это ушло в онлайн, что несколько сбивает настрой, но по-прежнему насыщенно хорошими докладами. Стоит отметить две наиболее популярные в наших краях конференции:

- Joker;
- JPoint.

Два брата акробата, первый традиционно проходит в Питере, второй — в Москве. Доклады часто пересекаются, но при желании можно спокойно ходить на обе конференции, благо они разнесены по сезонам. Видосы с прошлых сезонов стали открывать бесплатно всем желающим, к чему обязательно стоит приобщиться на [ютубе](https://www.youtube.com/c/JUGru/playlists).